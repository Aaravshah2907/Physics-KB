#!/bin/bash
# pkb-rebuild: Restructures an existing physics note for better flow, fills gaps, and ensures logical order.

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/pkb-common.sh"

if [ ! -d "$NOTES_DIR" ] || [ -z "$(ls -A "$NOTES_DIR")" ]; then
    echo "‚ùå No notes found in $NOTES_DIR"
    exit 1
fi

FILE_ARG="$1"
TARGET_FILE_NAME=$(resolve_target_file "$FILE_ARG" "üìÇ Select a note to rebuild:")

if [ -z "$TARGET_FILE_NAME" ]; then
    exit 0
fi

TARGET_FILE="$NOTES_DIR/$TARGET_FILE_NAME"

if [ ! -f "$TARGET_FILE" ]; then
    echo "‚ùå Error: File not found at $TARGET_FILE"
    exit 1
fi

# Track already rebuilt files to prevent infinite loops (recursive)
if [ -z "$PKB_REBUILT_SET" ]; then
    PKB_REBUILT_SET="|$TARGET_FILE|"
else
    if [[ "$PKB_REBUILT_SET" == *"|$TARGET_FILE|"* ]]; then
        exit 0
    fi
    PKB_REBUILT_SET="$PKB_REBUILT_SET$TARGET_FILE|"
fi
export PKB_REBUILT_SET

echo "üèóÔ∏è  Rebuilding $(basename "$TARGET_FILE")..."

# Step 1: Data Preparation
draw_task_progress 1 4 "Gathering context"
SYSTEM_PROMPT=$(cat "$GEMINI_CONF")
CURRENT_CONTENT=$(cat "$TARGET_FILE")
EXISTING_NOTES=$(get_existing_notes_list)
AVAILABLE_IMAGES=$(get_available_images)
echo ""

# Step 2: Smart Index-Based Splitting
# Update index first to ensure we have latest structure
"$PKB_SCRIPTS_DIR/pkb-index" >/dev/null 2>&1

INDEX_JSON="$PROJ_ROOT/topic_index.json"
TARGET_BASENAME=$(basename "$TARGET_FILE")

# Use Python to analyze index and generate split plan
SPLIT_PLAN=$(python3 "$PKB_SCRIPTS_DIR/pkb_split_planner.py" "$INDEX_JSON" "$TARGET_BASENAME" --threshold 15)

if [ "$SPLIT_PLAN" != "NO_SPLIT" ] && [ "$SPLIT_PLAN" != "NO_DATA" ] && [ -n "$SPLIT_PLAN" ]; then
    TOPIC_COUNT=$(jq -r '.topic_count // 0' <<< "$(jq -r ".files[] | select(.filename == \"$TARGET_BASENAME\")" "$INDEX_JSON")")
    printf "\r\033[K   ‚úÇÔ∏è  Large file detected ($TOPIC_COUNT topics). Performing smart split...\n" >&2
    
    # Execute split plan using external script
    python3 "$PKB_SCRIPTS_DIR/pkb_split_executor.py" "$SPLIT_PLAN" "$NOTES_DIR" "$TARGET_FILE"
    
    # After separation, update the index
    "$PKB_SCRIPTS_DIR/pkb-index" >/dev/null 2>&1
    
    echo "‚úÖ Smart split complete. Core file updated with links."
    exit 0
fi

if ! check_heading_limit "$TARGET_FILE" 20; then
    FORCE_SPLIT="true"
fi

# Recalculate heading count for context
HEADING_COUNT=$(grep -c "^##" "$TARGET_FILE")

draw_task_progress 2 4 "AI Optimization"
REBUILD_TASK=$(cat "$PROMPTS_DIR/rebuild.txt" | \
    sed "s/\${HEADING_LIMIT}/${PKB_HEADING_LIMIT:-20}/g" | \
    sed "s/\${HEADING_COUNT}/$HEADING_COUNT/g")

REBUILD_PROMPT="SYSTEM INSTRUCTIONS:
$SYSTEM_PROMPT

CONTEXT:
Other existing topics: [$EXISTING_NOTES]
Available images in assets: [$AVAILABLE_IMAGES]
Current file: $(basename "$TARGET_FILE") (Heading count: $HEADING_COUNT)

$REBUILD_TASK

Output ONLY the raw markdown content. No extra markers outside the splitter."

TEMP_DIR=$(mktemp -d)
echo "" # For the spinner
call_gemini "$REBUILD_PROMPT" > "$TEMP_DIR/output.txt"

TOUCHED_FILES=""

if [ $? -eq 0 ] && [ -s "$TEMP_DIR/output.txt" ]; then
    # Step 3: Deployment (Handling possible splits/moves)
    draw_task_progress 3 4 "Applying changes"
    OLD_BASE=$(basename "$TARGET_FILE" .md)
    
    if grep -q -- "---NEXT_FILE:" "$TEMP_DIR/output.txt"; then
        # Handle multiple files (Atomic Splits/Moves)
        csplit -k -s -f "$TEMP_DIR/part" "$TEMP_DIR/output.txt" "/---NEXT_FILE:/" "{*}"
        
        for PART in "$TEMP_DIR"/part*; do
            [ ! -s "$PART" ] && continue
            FNAME_RAW=$(grep -- "---NEXT_FILE:" "$PART" | sed 's/---NEXT_FILE:\(.*\).md---/\1/' | head -1 | tr -d '\r')
            FNAME=$(sanitize_filename "$FNAME_RAW")
            [ -z "$FNAME" ] && FNAME="$OLD_BASE"
            
            NEW_PATH="$NOTES_DIR/$FNAME.md"
            EXISTS=false
            [ -f "$NEW_PATH" ] && EXISTS=true
            
            sed '/---NEXT_FILE:/d' "$PART" > "$NEW_PATH"
            
            if [ "$FNAME" == "$OLD_BASE" ]; then
                printf "\r\033[K   üíæ Updated core file: $FNAME.md\n" >&2
            elif $EXISTS; then
                printf "\r\033[K   üöö Moved content to existing: $FNAME.md\n" >&2
            else
                printf "\r\033[K   üíæ Created atomic file: $FNAME.md\n" >&2
            fi
            
            # If we renamed or pivoted away from original base
            if [ "$FNAME" != "$OLD_BASE" ] && [[ "$FNAME_RAW" == *"$OLD_BASE"* ]]; then
                 update_global_links "$OLD_BASE" "$FNAME"
            fi

            TOUCHED_FILES+="$NEW_PATH "
            download_external_images "$NEW_PATH"
            extract_simulations "$NEW_PATH"
            SB_TOUCHED=$(sync_backlinks "$NEW_PATH")
            TOUCHED_FILES+="$SB_TOUCHED "
        done
        
        # Delete original if it was fully evacuated/renamed
        if ! grep -q -- "---NEXT_FILE:$(basename "$TARGET_FILE")" "$TEMP_DIR/output.txt" && ! grep -q -- "---NEXT_FILE:$OLD_BASE" "$TEMP_DIR/output.txt"; then
             [ -n "$TOUCHED_FILES" ] && rm "$TARGET_FILE"
        fi
    else
        # Single file (Potentially Renamed)
        NEW_TITLE=$(grep "^title: " "$TEMP_DIR/output.txt" | head -1 | sed 's/title: //;s/"//g;s/'\''//g')
        NEW_FNAME=$(sanitize_filename "$NEW_TITLE")
        
        if [ -n "$NEW_FNAME" ] && [ "$NEW_FNAME" != "$OLD_BASE" ]; then
            NEW_PATH="$NOTES_DIR/$NEW_FNAME.md"
            [ -f "$NEW_PATH" ] && printf "\r\033[K   üöö Merged content into: $NEW_FNAME.md\n" >&2 || printf "\r\033[K   üè∑Ô∏è  Renamed to: $NEW_FNAME.md\n" >&2
            
            mv "$TEMP_DIR/output.txt" "$NEW_PATH"
            rm -f "$TARGET_FILE"
            update_global_links "$OLD_BASE" "$NEW_FNAME"
            TARGET_FILE="$NEW_PATH"
        else
            mv "$TEMP_DIR/output.txt" "$TARGET_FILE"
        fi
        
        TOUCHED_FILES+="$TARGET_FILE "
        download_external_images "$TARGET_FILE"
        extract_simulations "$TARGET_FILE"
        SB_TOUCHED=$(sync_backlinks "$TARGET_FILE")
        TOUCHED_FILES+="$SB_TOUCHED "
    fi
    echo ""
    
    # Step 4: Recursive Rebuild of Modified Files
    draw_task_progress 4 4 "Indexing & cleaning up"
    
    UNIQUE_TOUCHED=$(echo "$TOUCHED_FILES" | tr ' ' '\n' | sort -u | tr '\n' ' ')
    
    for T_FILE in $UNIQUE_TOUCHED; do
        if [ -f "$T_FILE" ] && [ "$T_FILE" != "$TARGET_FILE" ]; then
            # Ensure the relative path is full
            [[ "$T_FILE" != /* ]] && T_FILE="$NOTES_DIR/$T_FILE"
            "$PKB_SCRIPTS_DIR/pkb-rebuild" "$T_FILE"
        fi
    done
    
    git_snapshot "Rebuild $(basename "$TARGET_FILE")"

    # Update Index and Todo List
    "$PKB_SCRIPTS_DIR/pkb-index" >/dev/null 2>&1
    "$PKB_SCRIPTS_DIR/pkb-todo" --update-only >/dev/null 2>&1

    echo ""
    echo "‚úÖ Success! File(s) optimized."
else
    echo "‚ùå Error during rebuild. Original file preserved."
    rm -rf "$TEMP_DIR"
    exit 1
fi
rm -rf "$TEMP_DIR"
